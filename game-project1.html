<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2D Adventure Game ‚Äî Miss D (Moving Platforms + Checkpoints)</title>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
<style>
  :root {
    --bg:#0b0d10; --panel:#101217; --muted:#b9c0d6;
    --accent:#8a7cff; --accent2:#ff7fbf; --success:#6ee7b7; --danger:#ff6b6b;
  }
  html,body{height:100%; margin:0; background:linear-gradient(180deg,#07070a,#0b1016); color:#e9eef8; font-family:Poppins,system-ui,Arial;}
  header{display:flex; align-items:center; justify-content:space-between; padding:18px 28px; background:transparent;}
  header h1{font-family:Pacifico, cursive; color:var(--accent2); margin:0;}
  header nav a{margin-left:18px; color:var(--accent); text-decoration:none; font-weight:600;}
  .hero{padding:28px 20px; text-align:center;}
  .hero h2{margin:8px 0 6px; font-size:28px;}
  .hero p{max-width:900px; margin:0 auto; color:var(--muted); line-height:1.6;}
  .wrap{max-width:1100px; margin:18px auto 60px; padding:0 18px;}
  .section{background:var(--panel); padding:18px; border-radius:12px; border:1px solid rgba(255,255,255,0.04); box-shadow:0 10px 30px rgba(0,0,0,0.6); margin-bottom:16px;}
  .section h3{margin:0 0 8px;} .section p{color:var(--muted); line-height:1.6;}
  .features{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
  .tag{background:linear-gradient(90deg,var(--accent),var(--accent2)); color:#071018; padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px;}
  .game-wrap{display:grid; grid-template-columns: 1fr 320px; gap:16px; align-items:start;}
  @media (max-width:980px){ .game-wrap{grid-template-columns:1fr;} }
  .panel-game{background:linear-gradient(180deg,#081018,#07121a); border-radius:12px; padding:12px; border:1px solid rgba(255,255,255,0.04);}
  #gameCanvas{display:block; width:100%; max-width:820px; height:auto; background: linear-gradient(#07111a,#07121d); border-radius:8px; border:1px solid rgba(255,255,255,0.03); box-shadow:0 16px 48px rgba(0,0,0,0.6);}
  .hud{display:flex; gap:12px; align-items:center; margin-bottom:8px;}
  .hud .box{background:rgba(255,255,255,0.02); padding:8px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); color:var(--muted); font-weight:600;}
  .controls{margin-top:10px; color:var(--muted); font-size:13px;}
  aside{min-width:240px;}
  aside .panel{padding:12px;}
  .btn{display:inline-block; padding:8px 12px; background:linear-gradient(90deg,var(--accent),var(--accent2)); color:#071018; font-weight:700; border-radius:10px; text-decoration:none;}
  .muted{color:var(--muted); font-size:14px;}
  .center{display:flex; gap:10px; align-items:center; justify-content:center;}
  .notice{padding:8px 12px; border-radius:8px; background:rgba(255,255,255,0.02); color:var(--muted); border:1px solid rgba(255,255,255,0.03);}
  footer{padding:20px; text-align:center; color:var(--muted);}
</style>
</head>
<body>

<header>
  <h1>Œî</h1>
  <nav>
    <a href="index.html">Home</a>
    <a href="about.html">About</a>
    <a href="portfolio.html" style="text-decoration: underline;">Portfolio</a>
    <a href="contact.html">Contact</a>
  </nav>
</header>

<section class="hero">
  <h2>2D Adventure ‚Äî Level Challenge Demo</h2>
  <p>Playable prototype with moving platforms and checkpoints. Use ‚Üê ‚Üí to move, Space to jump. Collect all coins to advance. Avoid enemies & hazards.</p>
</section>

<div class="wrap">
  <div class="section">
    <h3>Overview</h3>
    <p>This enhanced prototype adds moving (rideable) platforms and checkpoint respawns to the baseline platformer. It‚Äôs still pure Canvas + JS, modular, and ready for more mechanics.</p>
    <div class="features">
      <span class="tag">Moving Platforms</span>
      <span class="tag">Checkpoints</span>
      <span class="tag">Enemy AI</span>
      <span class="tag">Collectibles</span>
    </div>
  </div>

  <div class="game-wrap">
    <div class="panel-game">
      <div class="hud">
        <div class="box" id="scoreBox">Score: 0</div>
        <div class="box" id="livesBox">Lives: 3</div>
        <div class="box" id="levelBox">Level: 1</div>
      </div>

      <canvas id="gameCanvas" width="800" height="420" tabindex="0" aria-label="2D Adventure game canvas"></canvas>

      <div class="controls">
        Controls: <strong>‚Üê ‚Üí</strong> Move ‚Ä¢ <strong>Space</strong> Jump ‚Ä¢ <strong>R</strong> Restart Level
      </div>

      <div style="height:8px;"></div>
      <div class="center">
        <a class="btn" id="startBtn" href="#" role="button">Start / Resume</a>
        <a class="btn" id="resetBtn" href="#" role="button">Restart Game</a>
      </div>
    </div>

    <aside>
      <div class="panel">
        <h4 class="muted">Key Features</h4>
        <ul class="muted">
          <li>Moving, rideable platforms (move horizontally between ranges).</li>
          <li>Checkpoints update spawn position when touched.</li>
          <li>Patrolling enemies and hazards to avoid.</li>
          <li>Collect all coins to progress levels.</li>
        </ul>
      </div>

      <div class="panel">
        <h4 class="muted">HUD & Mechanics</h4>
        <p class="muted">Player rides moving platforms naturally. After being hit, player respawns at last checkpoint (or level start).</p>
      </div>

      <div class="panel notice">
        Tip: Click the canvas to focus keyboard input. This demo is modular‚Äîadd more moving platforms by giving a platform a <code>vx</code> and <code>range</code>.
      </div>
    </aside>
  </div>
</div>

<footer>
  <p>üì© Contact me: <a style="color:#fff" href="mailto:dxatelier.io@gmail.com">dxatelier.io@gmail.com</a></p>
  <p>&copy; 2025 Miss D</p>
</footer>

<script>
/* =========================
   2D Adventure ‚Äî Moving Platforms + Checkpoints
   ========================= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

const scoreBox = document.getElementById('scoreBox');
const livesBox = document.getElementById('livesBox');
const levelBox = document.getElementById('levelBox');
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');

function rectsOverlap(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

// Level definitions with moving platforms (platform can have vx and range) and checkpoint(s)
const baseLevels = [
  {
    platforms: [
      {x:0,y:380,w:800,h:40},
      {x:140,y:300,w:120,h:16},
      {x:320,y:240,w:120,h:16, vx: 1, range:[320,440]}, // moving platform
      {x:520,y:180,w:120,h:16}
    ],
    coins: [
      {x:170,y:270, collected:false},
      {x:350,y:210, collected:false},
      {x:550,y:150, collected:false}
    ],
    enemies: [
      {x:260,y:360,w:30,h:20, range:[220,320], speed:1.2}
    ],
    hazards:[
      {x:420,y:380,w:40,h:16}
    ],
    checkpoints:[
      {x:300,y:200,w:12,h:12} // small box to touch
    ],
    gravity: 0.6
  },
  {
    platforms: [
      {x:0,y:380,w:800,h:40},
      {x:100,y:320,w:100,h:16, vx: 1, range:[100,200]},
      {x:250,y:270,w:100,h:16},
      {x:420,y:220,w:100,h:16, vx:1.2, range:[420,520]},
      {x:560,y:160,w:100,h:16}
    ],
    coins: [
      {x:130,y:290, collected:false},
      {x:280,y:240, collected:false},
      {x:470,y:190, collected:false},
      {x:600,y:130, collected:false}
    ],
    enemies: [
      {x:200,y:360,w:28,h:18, range:[180,300], speed:1.6},
      {x:480,y:200,w:28,h:18, range:[460,560], speed:1.2}
    ],
    hazards:[
      {x:350,y:380,w:40,h:16},
      {x:700,y:380,w:40,h:16}
    ],
    checkpoints:[
      {x:520,y:190,w:12,h:12}
    ],
    gravity: 0.65
  }
];

// game state
let levels = []; // runtime copies
let currentLevel = 0;
let player = null;
let keys = {};
let running = false;
let last = performance.now();
let gameState = 'idle'; // idle | playing | gameover | win

// spawn and respawn handling (uses lastCheckpoint if set)
let lastCheckpoint = null;
function spawnPlayer(atCheckpoint){
  const start = atCheckpoint ? {x: atCheckpoint.x, y: atCheckpoint.y - 36} : {x:40, y:320};
  player = {
    x: start.x, y: start.y, w:28, h:28,
    dx:0, dy:0, speed:3.6, jumpPower:-12,
    grounded:false, lives:3, score:0, invuln:0
  };
  lastCheckpoint = null;
}

// deep-copy helper for level runtime state
function cloneLevels(){
  return baseLevels.map(l => ({
    platforms: l.platforms.map(p => ({...p})),
    coins: l.coins.map(c => ({...c, collected:false})),
    enemies: l.enemies.map(e => ({...e, dir:1, dead:false})),
    hazards: l.hazards.map(h => ({...h})),
    checkpoints: l.checkpoints ? l.checkpoints.map(c => ({...c, touched:false})) : [],
    gravity: l.gravity
  }));
}

// load level index
function loadLevel(idx){
  levels = cloneLevels();
  currentLevel = idx;
  // reset player to checkpoint if exists else default spawn
  if (levels[idx].checkpoints && levels[idx].checkpoints.length>0){
    // no checkpoint touched yet -> spawn at start
    spawnPlayer(null);
  } else spawnPlayer(null);
  gameState = 'idle';
  running = false;
  updateHUD();
}

// HUD
function updateHUD(){ scoreBox.textContent = 'Score: ' + player.score; livesBox.textContent = 'Lives: ' + player.lives; levelBox.textContent = 'Level: ' + (currentLevel+1); }

// keyboard
document.addEventListener('keydown', e => { keys[e.code]=true; if (e.code==='KeyR'){ e.preventDefault(); resetGame(); }});
document.addEventListener('keyup', e => keys[e.code]=false);

// start/reset UI
startBtn.addEventListener('click', e => { e.preventDefault(); if (gameState === 'win' || gameState === 'gameover') resetGame(); running = true; gameState='playing'; canvas.focus();});
resetBtn.addEventListener('click', e => { e.preventDefault(); resetGame(); canvas.focus();});

// helper: move platform logic
function updatePlatforms(plats, dt){
  for (const p of plats){
    if (p.vx && p.range){
      p.x += p.vx * dt;
      if (p.x < p.range[0]) { p.x = p.range[0]; p.vx *= -1; }
      if (p.x + p.w > p.range[1]) { p.x = p.range[1] - p.w; p.vx *= -1; }
    }
  }
}

// platform collision with riding support
function platformCollision(p){
  const nextY = player.y + player.h + player.dy;
  if (player.x + player.w > p.x && player.x < p.x + p.w){
    if (player.y + player.h <= p.y && nextY >= p.y){
      // land
      player.y = p.y - player.h;
      player.dy = 0;
      player.grounded = true;
      // if platform moves, carry the player horizontally by its vx
      if (p.vx){
        player.x += p.vx; // assume dt normalized ~1 for simplicity
      }
      return true;
    }
  }
  return false;
}

function hitPlayer(){
  if (player.invuln > 0) return;
  player.lives -= 1;
  player.invuln = 60; // invuln frames
  // respawn at last checkpoint if exists
  if (lastCheckpoint){
    player.x = lastCheckpoint.x;
    player.y = lastCheckpoint.y - 36;
  } else {
    player.x = 40; player.y = 320;
  }
  // reload level state to reset enemies/platforms positions for fairness: re-clone this level
  const idx = currentLevel;
  levels[currentLevel] = cloneLevels()[currentLevel];
  if (player.lives <= 0) showGameOver();
  updateHUD();
}

// draw helpers
function draw(){
  ctx.clearRect(0,0,W,H);
  // background
  ctx.fillStyle = '#071018'; ctx.fillRect(0,0,W,H);

  const lvl = levels[currentLevel];

  // draw platforms
  ctx.fillStyle = '#6b4f2f';
  for (const p of lvl.platforms){
    ctx.fillRect(p.x, p.y, p.w, p.h);
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.strokeRect(p.x+1, p.y+1, p.w-2, p.h-2);
  }

  // draw coins
  for (const c of lvl.coins){
    if (!c.collected){
      ctx.beginPath(); ctx.fillStyle='gold'; ctx.arc(c.x,c.y,8,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(c.x-3,c.y+5,6,2);
    }
  }

  // draw checkpoints
  for (const cp of lvl.checkpoints){
    ctx.fillStyle = cp.touched ? 'rgba(110,231,183,0.9)' : 'rgba(120,120,200,0.6)';
    ctx.fillRect(cp.x, cp.y, cp.w, cp.h);
    ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.strokeRect(cp.x, cp.y, cp.w, cp.h);
  }

  // hazards
  ctx.fillStyle='#b33';
  for (const h of lvl.hazards){
    const spikes = Math.max(2, Math.floor(h.w/10));
    for (let i=0;i<spikes;i++){
      const sx = h.x + i*10;
      ctx.beginPath(); ctx.moveTo(sx, h.y + h.h); ctx.lineTo(sx+5, h.y); ctx.lineTo(sx+10, h.y + h.h); ctx.closePath(); ctx.fill();
    }
  }

  // enemies
  ctx.fillStyle='#c33';
  for (const e of lvl.enemies){
    if (e.dead) continue;
    ctx.fillRect(e.x, e.y, e.w, e.h);
    ctx.fillStyle='#111'; ctx.fillRect(e.x + Math.max(2, e.w/2 -6), e.y+4, 4, 4);
    ctx.fillStyle='#c33';
  }

  // player blink during invuln
  if (Math.floor(player.invuln/6) % 2 === 0){
    ctx.fillStyle = '#8a7cff';
    ctx.fillRect(player.x, player.y, player.w, player.h);
    // face
    ctx.fillStyle = '#071018';
    ctx.fillRect(player.x+6, player.y+8, 4,4); ctx.fillRect(player.x+16, player.y+8,4,4);
  }

  // HUD overlay
  ctx.fillStyle = 'rgba(0,0,0,0.16)'; ctx.fillRect(8,8,180,46);
  ctx.fillStyle = '#fff'; ctx.font='14px Poppins, Arial';
  ctx.fillText('Score: '+player.score, 18, 28); ctx.fillText('Lives: '+player.lives, 18, 46);

  if (gameState === 'gameover'){
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#ff6b6b'; ctx.font='48px Poppins, Arial'; ctx.textAlign='center';
    ctx.fillText('GAME OVER', W/2, H/2 - 10); ctx.font='18px Poppins, Arial';
    ctx.fillText('Click Restart to try again', W/2, H/2 + 24);
  }
  if (gameState === 'win'){
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#6ee7b7'; ctx.font='44px Poppins, Arial'; ctx.textAlign='center';
    ctx.fillText('YOU COMPLETED THE GAME!', W/2, H/2 - 6); ctx.font='18px Poppins, Arial';
    ctx.fillText('Thanks for playing ‚Äî epic job!', W/2, H/2 + 28);
  }
  ctx.textAlign='start';
}

// update loop
function update(dt){
  if (!running || gameState==='gameover' || gameState==='win') return;
  const lvl = levels[currentLevel];

  // move platforms first (so collision reflects movement)
  updatePlatforms(lvl.platforms, dt);

  // player input
  if (keys['ArrowLeft']) player.dx = -player.speed;
  else if (keys['ArrowRight']) player.dx = player.speed;
  else player.dx = 0;

  // jump
  if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.grounded){
    player.dy = player.jumpPower;
    player.grounded = false;
  }

  // apply gravity
  player.dy += lvl.gravity;
  player.x += player.dx;
  player.y += player.dy;

  // bounds
  if (player.x < 0) player.x = 0;
  if (player.x + player.w > W) player.x = W - player.w;
  if (player.y > H + 200){ // fell far below -> lose life
    hitPlayer();
  }

  // platform collisions ‚Äî check all; riding moving platforms is handled in platformCollision
  player.grounded = false;
  for (const p of lvl.platforms){
    platformCollision(p);
  }

  // coin collection
  for (const c of lvl.coins){
    if (!c.collected){
      const coinRect = {x:c.x-8,y:c.y-8,w:16,h:16};
      if (rectsOverlap(player, coinRect)){
        c.collected = true;
        player.score += 10;
        updateHUD();
      }
    }
  }

  // checkpoint detection
  for (const cp of lvl.checkpoints){
    if (!cp.touched){
      const cpRect = {x:cp.x,y:cp.y,w:cp.w,h:cp.h};
      if (rectsOverlap(player, cpRect)){
        cp.touched = true;
        lastCheckpoint = {x: cp.x, y: cp.y};
        // visual feedback: small score bonus
        player.score += 5;
        updateHUD();
      }
    }
  }

  // enemies patrol & interactions
  for (const e of lvl.enemies){
    if (e.dead) continue;
    e.x += e.speed * (e.dir || 1) * dt;
    if (!e.dir) e.dir = 1;
    if (e.x < e.range[0]) e.dir = 1;
    if (e.x > e.range[1]) e.dir = -1;

    const enemyRect = {x:e.x,y:e.y,w:e.w,h:e.h};
    if (rectsOverlap(player, enemyRect)){
      if (player.dy > 2){
        // stomp
        e.dead = true; player.dy = player.jumpPower * 0.6; player.score += 20; updateHUD();
      } else {
        if (player.invuln <= 0) hitPlayer();
      }
    }
  }

  // hazards
  for (const h of lvl.hazards){
    const hazardRect = {x:h.x,y:h.y,w:h.w,h:h.h};
    if (rectsOverlap(player, hazardRect)){
      if (player.invuln <= 0) hitPlayer();
    }
  }

  // invulnerability decrement
  if (player.invuln > 0) player.invuln -= dt;

  // win check
  if (lvl.coins.every(c => c.collected)){
    running = false;
    setTimeout(() => {
      currentLevel++;
      if (currentLevel >= levels.length){
        showWin();
      } else {
        loadLevel(currentLevel);
        running = true;
      }
    }, 600);
  }

  updateHUD();
}

// reset level (keep lives but reset environment)
function resetLevel(){
  loadLevel(currentLevel);
  player.lives = Math.max(1, player.lives);
  running = false; gameState='idle'; updateHUD();
}

// full restart
function resetGame(){
  currentLevel = 0;
  levels = cloneLevels();
  spawnPlayer(null);
  player.lives = 3; player.score = 0; lastCheckpoint = null;
  running = false; gameState='idle'; updateHUD();
}

// show overlays
function showGameOver(){ gameState='gameover'; running=false; }
function showWin(){ gameState='win'; running=false; }

// main draw & loop
function loop(now){
  const dt = Math.min(60, now - last) / (1000/60); last = now;
  if (running && gameState === 'idle') gameState = 'playing';
  if (gameState === 'playing' || gameState === 'idle') update(dt);
  draw();
  requestAnimationFrame(loop);
}

// init
function init(){
  levels = cloneLevels();
  loadLevel(0);
  spawnPlayer(null);
  last = performance.now();
  requestAnimationFrame(loop);
}

// focus keyboard on canvas
canvas.addEventListener('click', ()=> canvas.focus());
canvas.setAttribute('tabindex','0');
canvas.addEventListener('keydown', (e)=> { if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault(); });

// start/reset bindings
startBtn.addEventListener('click', (e)=> { e.preventDefault(); if (gameState==='win'||gameState==='gameover') resetGame(); running=true; gameState='playing'; canvas.focus();});
resetBtn.addEventListener('click', (e)=> { e.preventDefault(); resetGame(); canvas.focus();});

// initial launch
init();
</script>

</body>
</html>
